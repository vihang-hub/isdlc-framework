# Security Architecture -- REQ-0011: Adaptive Workflow Sizing

**Version**: 1.0.0
**Created**: 2026-02-12
**Phase**: 03-architecture
**Traces to**: NFR-04 (Constitutional Compliance), Article III (Security by Design), Article X (Fail-Safe Defaults)

---

## 1. Threat Model (STRIDE Analysis)

The adaptive workflow sizing feature operates entirely within the local filesystem -- no network calls, no authentication, no encryption needed. The threat model focuses on **state integrity** and **fail-safe behavior**.

### 1.1 Threats

| Category | Threat | Severity | Mitigation |
|----------|--------|----------|------------|
| **Tampering** | Malformed impact-analysis.md causes incorrect sizing | Medium | `parseSizingFromImpactAnalysis` validates all extracted values. Non-numeric file counts default to 0. Unrecognized risk scores default to "medium". |
| **Tampering** | Manual edits to state.json corrupt sizing state | Low | `applySizingDecision` runs invariant checks after mutation. If invariants fail, reverts to standard (no modification). |
| **Tampering** | Malicious workflows.json thresholds (e.g., light_max_files: 999) | Low | Thresholds are validated: `light_max_files < epic_min_files`. If invalid, defaults to hardcoded values (5 and 20). |
| **Denial of Service** | Extremely large impact-analysis.md blocks sizing | Very Low | The file is read synchronously in the conversation thread. Maximum practical size is ~50KB (markdown). No external I/O. NFR-01 requires <5s completion. |
| **Elevation of Privilege** | Agent attempts to skip phases without going through sizing | Medium | `gate-blocker.cjs` validates phase progression against `active_workflow.phases`. An agent cannot delegate to a phase not in the array. `phase-sequence-guard.cjs` validates the current phase matches state. |
| **Information Disclosure** | Sizing data leaks sensitive project info | Very Low | Sizing data (file counts, risk scores) is non-sensitive. Stored in local state.json which is gitignored. |
| **Repudiation** | User overrides sizing but no audit trail | Low | `active_workflow.sizing` records `overridden: true`, `overridden_to: "standard"`, `decided_at` timestamp. Persisted to `workflow_history`. |

### 1.2 Risk Assessment Summary

Overall risk: **LOW**. The feature operates entirely locally, introduces no new attack surface, and handles untrusted input (impact-analysis.md) with validation and fail-safe defaults.

---

## 2. Input Validation

### 2.1 impact-analysis.md Parsing

The `parseSizingFromImpactAnalysis(content)` function processes markdown content that was generated by the framework's own IA agent. However, since the content is a text file that could be manually edited, all values are validated:

| Field | Validation | Default on Invalid |
|-------|-----------|-------------------|
| `files_directly_affected` | Must be non-negative integer | 0 |
| `modules_affected` | Must be non-negative integer | 0 |
| `risk_level` | Must be one of: "low", "medium", "high" | "medium" |
| `blast_radius` | Must be one of: "low", "medium", "high" | "medium" |
| `coverage_gaps` | Must be non-negative integer | 0 |

If the JSON metadata block cannot be parsed at all, the function returns `null` and the caller defaults to `standard` intensity.

### 2.2 workflows.json Thresholds

Read from configuration file. Validated before use:

```javascript
// Validation in computeSizingRecommendation
if (typeof thresholds.light_max_files !== 'number' || thresholds.light_max_files < 0) {
    thresholds.light_max_files = 5; // hardcoded default
}
if (typeof thresholds.epic_min_files !== 'number' || thresholds.epic_min_files < 0) {
    thresholds.epic_min_files = 20; // hardcoded default
}
if (thresholds.light_max_files >= thresholds.epic_min_files) {
    thresholds.light_max_files = 5;
    thresholds.epic_min_files = 20;
}
```

### 2.3 Intensity Parameter

The `intensity` parameter passed to `applySizingDecision` is validated against the enum `['light', 'standard', 'epic']`. Any other value is rejected with a fall back to `standard`.

---

## 3. State Integrity Protection

### 3.1 Atomic Multi-Field Mutation

`applySizingDecision` modifies multiple interrelated fields in state.json:
- `active_workflow.phases` (array)
- `active_workflow.phase_status` (object)
- `active_workflow.current_phase_index` (number)
- `active_workflow.sizing` (object)
- `phases` (top-level object)

All mutations are applied to the in-memory state object first, then validated, then written in a single `writeState()` call. There is no partial-write risk because the entire state.json file is written atomically (Node.js `fs.writeFileSync` with complete content).

### 3.2 Invariant Validation (Post-Mutation)

After mutation and before returning, `applySizingDecision` checks:

1. **Array length**: `active_workflow.phases.length >= 3`
2. **Index bounds**: `current_phase_index < active_workflow.phases.length`
3. **Consistency**: every key in `phase_status` exists in `phases` array
4. **Next phase status**: `phases[current_phase_index]` has status `"pending"`

If any invariant fails, the function:
1. Logs a warning to stderr (Article X: fail-safe)
2. Restores the original state (reverts all mutations)
3. Sets `sizing.intensity = "standard"` with a note `sizing.fallback_reason = "invariant_check_failed"`
4. Returns the unmodified state

### 3.3 Double-Sizing Prevention

STEP 3e-sizing checks `active_workflow.sizing` before executing. If the field already exists, sizing is skipped. This prevents:
- Re-entry after retry
- Duplicate sizing if the Phase-Loop Controller re-reads state
- Race conditions (not applicable -- single-threaded execution)

---

## 4. Authorization Model

### 4.1 Who Can Modify Sizing

| Actor | Can Trigger Sizing | Can Override | Can Modify State |
|-------|-------------------|--------------|-----------------|
| Phase-Loop Controller (isdlc.md) | Yes (STEP 3e-sizing) | N/A | Yes (via applySizingDecision) |
| User | N/A | Yes (via UX menu) | Indirectly (via Phase-Loop Controller) |
| Phase agents (01-08) | No | No | No |
| Hooks | No | No | No (observational only for sizing) |
| Orchestrator | No (only passes -light flag) | No | No (only initializes flags) |

### 4.2 Phase Removal Authorization

Only the framework (via `applySizingDecision` called from STEP 3e-sizing) can remove phases from the workflow. This is enforced by:
- The `no_agent_phase_skipping` rule (renamed from `no_phase_skipping`)
- The `gate-blocker` hook which validates phase progression against `active_workflow.phases`
- The `phase-sequence-guard` which validates the current phase matches state

Agents cannot call `applySizingDecision` directly -- it is a hook utility function, and agents do not execute Node.js code.

---

## 5. Fail-Safe Defaults (Article X)

### 5.1 Default Intensity

The default intensity is always `standard`. Any failure in the sizing pipeline results in `standard` intensity, which is the current behavior (no phases skipped, no state modification beyond adding the sizing record).

### 5.2 Failure Cascade

```
parseSizingFromImpactAnalysis fails
  -> returns null
    -> computeSizingRecommendation receives null metrics
      -> returns { intensity: "standard", rationale: "Unable to parse IA metrics" }
        -> applySizingDecision("standard")
          -> no phase modification, sizing record written
            -> workflow proceeds exactly as before
```

### 5.3 Missing Configuration

```
workflows.json missing feature.sizing
  -> STEP 3e-sizing reads feature.sizing as undefined
    -> sizing.enabled is falsy
      -> STEP 3e-sizing skips entirely
        -> workflow proceeds exactly as before
```

---

## 6. Compliance

### 6.1 Constitutional Article Compliance

| Article | Requirement | How Sizing Complies |
|---------|-------------|-------------------|
| Article I (Spec Primacy) | Sizing thresholds documented in spec | Thresholds in workflows.json, referenced in requirements-spec.md |
| Article III (Security by Design) | Security considered before implementation | This document (threat model, input validation, state integrity) |
| Article IV (Explicit Over Implicit) | No undocumented assumptions | All assumptions documented in architecture-overview.md and ADRs |
| Article V (Simplicity First) | Simplest solution | 3 pure functions + 1 markdown step. No new files, no new dependencies |
| Article VII (Artifact Traceability) | Every element traces to requirement | Traceability matrix in architecture-overview.md section 12 |
| Article IX (Quality Gate Integrity) | Gates cannot be skipped | Sizing removes phases BEFORE they are encountered. Remaining gates still enforced. Removed phases have no gates to skip. |
| Article X (Fail-Safe Defaults) | Fail securely | Default to standard on any error. Invariant checks. Single-write atomicity. |

### 6.2 `no_phase_skipping` Rule

The existing `no_phase_skipping: true` rule in workflows.json is clarified (ADR-0004):
- **Agent-level skipping**: Still forbidden. Agents cannot bypass phases.
- **Framework-level sizing**: Permitted. The framework modifies the phase array before any agent encounters those phases. From the perspective of agents and hooks, the removed phases never existed in the workflow.

---

## 7. Secrets Management

Not applicable. Adaptive workflow sizing introduces no secrets, credentials, API keys, or sensitive data. All data (file counts, risk scores, intensity decisions) is non-sensitive project metadata stored in gitignored state.json.
