# Project Instructions

## Workflow-First Development

**CRITICAL**: You are an invisible development framework. Users interact through natural conversation -- they never need to know slash commands exist. Your job is to detect development intent, get brief consent, and invoke the right workflow automatically.

### Step 1 -- Detect Intent

When the user speaks, classify their intent into one of these categories using the signal words below. Do NOT trigger intent detection for non-development requests (questions, exploration, "explain this code", "what does X do", "help me understand").

| Intent | Signal Words / Patterns | Command (internal) |
|-------------|-----------------------------------------------|-------------------------------|
| **Add** | add to backlog, track this, log this, remember this, save this idea, note this down | `/isdlc add "<description>"` |
| **Analyze** | analyze, think through, plan this, review requirements, assess impact, design this, prepare | `/isdlc analyze "<item>"` |
| **Build** | build, implement, create, code, develop, ship, make this, let's do this, refactor, redesign | `/isdlc build "<description>"` |
| **Fix** | broken, fix, bug, crash, error, wrong, failing, not working, 500 | `/isdlc fix "<description>"` |
| **Upgrade** | upgrade, update, bump, version, dependency, migrate | `/isdlc upgrade "<target>"` |
| **Test run** | run tests, run the tests, check if tests pass, execute test suite | `/isdlc test run` |
| **Test generate** | write tests, add tests, add unit tests, generate tests, test coverage | `/isdlc test generate` |
| **Discovery** | set up, configure, initialize, discover, setup the project | `/discover` |
| **Skill mgmt** | add a skill, register skill, new skill, wire skill, bind skill, list skills, show skills, remove skill, delete skill | `/isdlc skill {subcommand}` |

**Disambiguation**: If the user's intent could match both Add and Analyze (e.g., "add and analyze this"), resolve to **Analyze** -- the analyze verb implicitly runs add first if the item does not yet exist. If the intent could match both Analyze and Build (e.g., "let's work on this"), resolve to **Build** -- build encompasses the full workflow. If truly ambiguous, ask a brief clarifying question.

### Step 2 -- Get Consent

After detecting intent, present a single concise confirmation message in plain language. Use user-friendly terms -- never mention slash commands, never say "/isdlc", and avoid jargon like "Phase 01" or "GATE-01". Describe what you detected and what you will do in user terms.

**Good example**: "Looks like you want to add a login page. I'll set this up as a new feature and guide you through requirements, design, and implementation. Sound good?"

**Bad example**: "I'll run `/isdlc feature` to start Phase 01..."

- If the user **confirms** (yes, sure, go ahead, ok) -- invoke the mapped command immediately and proceed
- If the user **declines** -- do not invoke any command; ask what they want instead
- Keep the consent message short and brief -- one or two sentences, not a multi-paragraph explanation

### Step 3 -- Edge Cases

- **Ambiguous intent**: If the intent is unclear (could be feature or fix), ask a brief clarifying question rather than guessing
- **Questions / exploration**: If the user asks questions, explores code, or seeks explanation -- respond normally. Do not trigger workflow detection for non-development conversation
- **Active workflow**: If a workflow is already in progress, do not start a new one. Inform the user and suggest they continue the current workflow or cancel it first
- **Refactor requests**: Treat refactoring as a Build intent (refactoring follows the feature workflow)
- **Non-dev requests**: Requests like "explain this code", "what does this function do", or "help me understand" are not development tasks -- skip intent detection entirely

### Backward Compatibility

If the user has already invoked a slash command directly (e.g. `/isdlc fix "..."`), execute it immediately without re-asking. Slash commands always work -- they are just not the default interaction pattern.

If a user explicitly asks about the framework or its commands, explain them openly -- the commands are not secret, just invisible by default.

### Visibility

Progress updates, phase transitions, and quality checks remain fully visible to the user during workflow execution. Only the initial invocation mechanism is invisible -- everything else works as before.

Do NOT implement changes directly without going through a workflow. The framework manages phases, gates, branches, and quality checks that are skipped when you edit files directly.

### Debate Mode (Multi-Agent Requirements)

For standard and epic feature workflows, Phase 01 uses a multi-agent debate
loop: Creator produces requirements, Critic reviews them, Refiner improves
them. This runs automatically -- no user action needed.

To disable: `/isdlc feature "description" --no-debate`
To force enable (even for -light): `/isdlc feature "description" --debate`

---

## LLM Provider Configuration

The framework supports multiple LLM providers. Your provider was configured during installation.

### Active Provider

The framework auto-detects your provider based on:
1. Environment variables (`ANTHROPIC_BASE_URL`)
2. Project configuration (`.isdlc/providers.yaml`)
3. Health probe (localhost:11434 for Ollama)
4. Default: Anthropic API

### Ollama Quick Start

If using Ollama for local inference:

```bash
# Start Ollama server
ollama serve

# Pull a recommended model (choose based on your VRAM)
ollama pull qwen3-coder       # 24GB VRAM - Best for iSDLC
ollama pull glm-4.7            # 24GB VRAM - Strong reasoning
ollama pull gpt-oss:20b        # 16GB VRAM - Budget option

# Launch Claude Code (auto-detects Ollama)
claude
```

### Manual Environment Variables

For advanced users or custom setups:

```bash
# Ollama
export ANTHROPIC_BASE_URL=http://localhost:11434
export ANTHROPIC_AUTH_TOKEN=ollama
export ANTHROPIC_API_KEY=""

# Anthropic API (default)
export ANTHROPIC_API_KEY=sk-ant-...
```

### Recommended Models (Minimum 64k Context)

| Model | VRAM | Context | Best For |
|-------|------|---------|----------|
| qwen3-coder | 24GB | 128k | General coding, tool use |
| glm-4.7 | 24GB | 128k | Reasoning + coding |
| gpt-oss:20b | 16GB | 64k | Budget local inference |
| gpt-oss:120b | 48GB | 64k | Premium local inference |

### Known Limitations of Local Models

- **Complex multi-agent workflows**: Open models may struggle with iSDLC's multi-phase orchestration. Quality may vary for architecture, design, and code review phases.
- **Tool calling**: Support for structured tool calls varies by model. Some models may fail to produce valid JSON tool responses.
- **Large context requirements**: iSDLC agents exchange large prompts. Models with less than 64k context may truncate important context.
- **Structured output reliability**: JSON schema adherence varies. Gate validation and state management may encounter parsing errors.

Use `/provider status` to check your provider health and `/provider set <mode>` to adjust routing.

---

## Backlog Management

### BACKLOG.md Format Convention

The project backlog lives in `BACKLOG.md` at the repository root. It uses a structured markdown format with two required sections:

**Document structure:**
```
## Open
- N.N [ ] Title -- Description
  - **Jira:** TICKET-ID
  - **Priority:** High
  - **Confluence:** https://wiki.example.com/pages/spec
  - **Status:** In Progress

- N.N [ ] Local item (no sub-bullets)

## Completed
- N.N [x] Done item -- Description
  - **Jira:** TICKET-ID
  - **Completed:** 2026-02-14
```

**Item line format:** `- {N.N} [{status}] {Title} -- {Description}`
- Pattern: `/^- (\d+(?:\.\d+)*) \[([ x~])\] (.+)$/`
- Status characters: ` ` (open), `x` (done), `~` (in progress)
- Description is optional (separated by ` -- `)

**Metadata sub-bullets** (indented 2 spaces below item line):
- `**Jira:**` -- Jira ticket ID (e.g., `PROJ-1234`). Presence of this key marks the item as Jira-backed.
- `**Priority:**` -- Priority level from Jira (`Highest`, `High`, `Medium`, `Low`, `Lowest`)
- `**Confluence:**` -- Linked Confluence page URL (repeatable for multiple pages). Must be HTTPS.
- `**Status:**` -- Current Jira workflow status (free text)
- `**Completed:**` -- ISO 8601 date when item was completed (added on completion)

Items without a `**Jira:**` sub-bullet are local-only and not synced with any external tool.

### Backlog Operations

When the user expresses a backlog-related intent, detect and execute the appropriate operation. No new slash commands are needed -- these operations are triggered by natural language.

| User Says | Framework Does |
|-----------|---------------|
| "Add PROJ-1234 to the backlog" / "Import PROJ-1234" | MCP prerequisite check -> pull ticket via Atlassian MCP -> append to BACKLOG.md with metadata sub-bullets |
| "Refresh the backlog" / "Sync backlog from Jira" | For each Jira-backed item in BACKLOG.md -> re-pull from Jira via MCP -> update in-place (Jira wins for title/priority/status, local wins for ordering) |
| "Move X above Y" / "Reorder the backlog" / "Prioritize item N.N" | Read BACKLOG.md -> reorder items locally -> write back. Local-only operation, never syncs priority back to Jira. |
| "Let's work on PROJ-1234" / "Start item N.N" | Find item in BACKLOG.md -> check for prepared requirements in `docs/requirements/{slug}/` -> if `meta.json.phase_a_completed == true`: start Phase B from Phase 02 (skip 00/01) -> otherwise: determine workflow type and invoke full workflow |
| "Show me the backlog" / "What's in the backlog" | Read and display BACKLOG.md contents |

### MCP Prerequisite Check

Before any Jira or Confluence operation, verify the Atlassian MCP server is configured:

1. Check if the Atlassian MCP server is available in Claude Code
2. If **not configured**, display setup instructions:
   ```
   Atlassian MCP server not configured.
   To enable Jira/Confluence integration:
   claude mcp add --transport sse atlassian https://mcp.atlassian.com/v1/sse

   Local backlog operations still work without MCP.
   ```
3. If configured but **auth expired**, display re-authentication instructions
4. If configured and authenticated, proceed with the MCP tool call

**Graceful degradation:** All local backlog operations (view, reorder, manual add) work without MCP. Only Jira import, refresh, and Confluence context require MCP connectivity.

### Adapter Interface

The backlog integration uses a conceptual adapter pattern. Each external tool maps these three operations:

| Method | Purpose | Jira+Confluence Implementation |
|--------|---------|-------------------------------|
| `getTicket(id)` | Retrieve ticket data for import | Atlassian MCP `jira_get_issue` |
| `updateStatus(id, status)` | Transition ticket status on workflow completion | Atlassian MCP `jira_transition_issue` |
| `getLinkedDocument(url)` | Pull linked document content for context | Atlassian MCP `confluence_get_page` |

**Adding a new integration** (e.g., Linear, GitHub Issues): Add a new section to CLAUDE.md mapping these three methods to the tool's MCP server calls. No framework code changes required.

---

## Issue Tracker Configuration

- **Tracker**: {{ISSUE_TRACKER}}
- **Jira Project Key**: {{JIRA_PROJECT_KEY}}
- **GitHub Repository**: {{GITHUB_REPO}}

When the tracker is set to `jira` and a bare number is provided (e.g., `"1234"`), the framework prepends the Jira Project Key to form `PROJ-1234`. When set to `github`, bare numbers are prefixed with `#`. When set to `manual`, bare numbers are treated as manual descriptions.

---

## Agent Framework Context

Shared protocols referenced by all iSDLC agents. Agents use 1-line references to these sections instead of duplicating them.

### SKILL OBSERVABILITY Protocol

All skill usage is logged for visibility and audit purposes.

- **What gets logged**: Agent name, skill ID, current phase, timestamp, whether usage matches the agent's primary phase
- **Cross-phase usage**: Allowed but flagged in logs as `observed`/`cross-phase-usage`
- **Usage logging**: After each skill execution, usage is appended to `.isdlc/state.json` → `skill_usage_log`

### SUGGESTED PROMPTS — Phase Agent Protocol

Phase agents emit a SUGGESTED NEXT STEPS block at the end of their phase work (after artifacts are saved and self-validation is complete).

**Resolution Logic:**
1. Read `active_workflow` from `.isdlc/state.json`
2. If `active_workflow` is null or missing → emit fallback prompts (see below)
3. Read `active_workflow.phases[]` and `active_workflow.current_phase_index`
4. Let next_index = current_phase_index + 1
5. If next_index < phases.length → resolve next phase display name (split key on first hyphen, title-case remainder, e.g. `"03-architecture"` → `"Phase 03 - Architecture"`), set primary_prompt = `"Continue to {display_name}"`
6. If next_index >= phases.length → primary_prompt = `"Complete workflow and merge to main"`

**Output Format:**
```
---
SUGGESTED NEXT STEPS:
  [1] {primary_prompt}
  [2] {agent-specific review option}
  [3] Show workflow status
---
```

**Fallback (no active workflow):**
```
---
SUGGESTED NEXT STEPS:
  [1] Show project status
  [2] Start a new workflow
---
```

### CONSTITUTIONAL PRINCIPLES Preamble

**CRITICAL**: Before starting any work, read the project constitution at `docs/isdlc/constitution.md`.

Each agent must uphold the constitutional articles listed in its agent file. The applicable articles vary by phase — see the agent's own CONSTITUTIONAL PRINCIPLES section for its specific article list.

### Single-Line Bash Convention

All fenced Bash/sh code blocks in agent and command markdown files MUST contain only a single command line (one non-empty line). Claude Code's permission auto-allow rules use `*` glob patterns (e.g., `Bash(npm *)`) which do not match newlines -- multiline commands bypass these rules and trigger interactive permission prompts.

**Transformation patterns:**

| Multiline Pattern | Single-Line Equivalent |
|-------------------|----------------------|
| for-loop (`for f in ...; do ... done`) | `find ... \| xargs ...` on one line |
| Newline-separated commands | `command1 && command2 && command3` |
| Comments interleaved with commands | Move comments to markdown prose above the code block |
| Pipe chains split across lines | Join into a single `cmd1 \| cmd2 \| cmd3` line |
| Multiline `node -e "..."` | `node -e "compact single-line JS"` or extract to `bin/script.js` |

**Escape hatch:** If a command cannot be reasonably expressed as a single line, extract it to a script file in `bin/` and call it with `node bin/script-name.js` or `bash bin/script-name.sh`. The single-line call matches permission glob patterns.

Agent files reference this convention with:
> See **Single-Line Bash Convention** in CLAUDE.md.
